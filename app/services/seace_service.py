"""\nServicio para consultar información de obras en SEACE\n"""\nfrom playwright.async_api import async_playwright, Page, TimeoutError as PlaywrightTimeoutError\nfrom typing import Optional\nimport logging\n\nfrom app.models.seace import ObraSEACE\nfrom app.utils.exceptions import ExtractionException\n\nlogger = logging.getLogger(__name__)\n\n\nclass SEACEService:\n    """Servicio para extraer información de obras desde SEACE"""\n    \n    BASE_URL = "https://prod2.seace.gob.pe/seacebus-uiwd-pub/buscadorPublico/buscadorPublico.xhtml"\n    \n    async def consultar_obra(self, cui: str, anio: int) -> ObraSEACE:\n        """\n        Consulta información completa de una obra en SEACE por CUI y año\n        \n        Args:\n            cui: Código Único de Inversión\n            anio: Año de la convocatoria\n            \n        Returns:\n            ObraSEACE con toda la información extraída\n            \n        Raises:\n            ExtractionException: Si hay error en la extracción\n        """\n        logger.info(f"Iniciando consulta SEACE para CUI: {cui}, Año: {anio}")\n        \n        async with async_playwright() as p:\n            browser = await p.chromium.launch(\n                headless=True,\n                args=['--no-sandbox', '--disable-setuid-sandbox']\n            )\n            \n            try:\n                page = await browser.new_page()\n                page.set_default_timeout(30000)  # 30 segundos timeout por defecto\n                \n                # Navegar a SEACE\n                await self._navegar_a_seace(page)\n                \n                # Ejecutar búsqueda\n                await self._ejecutar_busqueda(page, cui, anio)\n\n                # Navegar al historial\n                await self._navegar_a_historial(page, cui)\n\n                # Navegar a la ficha de selección\n                await self._navegar_a_ficha_seleccion(page)\n                \n                # Extraer información de la ficha\n                obra_info = await self._extraer_informacion_ficha(page, cui, anio)\n                \n                logger.info(f"Consulta SEACE exitosa para CUI {cui}")\n                return obra_info\n                \n            except PlaywrightTimeoutError as e:\n                logger.error(f"Timeout en consulta SEACE para CUI {cui}: {str(e)}")\n                raise ExtractionException(f"Timeout consultando SEACE: {str(e)}")\n            except Exception as e:\n                logger.error(f"Error consultando SEACE para CUI {cui}: {str(e)}")\n                raise ExtractionException(f"Error al consultar SEACE: {str(e)}")\n            finally:\n                await browser.close()\n    \n    async def _navegar_a_seace(self, page: Page):\n        """Navega a la página principal de SEACE"""\n        logger.info(f"Navegando a SEACE: {self.BASE_URL}")\n        await page.goto(self.BASE_URL, wait_until='networkidle', timeout=60000)\n\n        # Esperar a que el tab activo cargue completamente\n        await page.wait_for_selector('.ui-tabs-selected.ui-state-active', timeout=30000, state='visible')\n        logger.info("Tab de búsqueda activo")\n\n        # Esperar tiempo adicional para que JavaScript inicialice el formulario\n        # En headless puede tomar más tiempo que en modo gráfico\n        await page.wait_for_timeout(8000)\n        logger.info("Esperando inicialización del formulario (8 segundos)")\n\n        # Verificar que el campo CUI exista (sin validar visibilidad estricta)\n        # Los dos puntos en IDs JSF deben escaparse en querySelector\n        cui_input_id = 'tbBuscador\\\\:idFormBuscarProceso\\\\:CUI'\n        await page.wait_for_function(\n            f'document.querySelector("#{cui_input_id}") !== null',\n            timeout=30000\n        )\n        logger.info("Campo CUI encontrado - Página SEACE cargada correctamente")\n    \n    async def _ejecutar_busqueda(self, page: Page, cui: str, anio: int):\n        """Ejecuta la búsqueda por año en SEACE (el CUI se busca en los resultados)"""\n        logger.info(f"Ejecutando búsqueda: Año={anio} (el CUI {cui} se buscará en los resultados)")\n\n        try:\n            # Seleccionar el año - PrimeFaces dropdown (click to open, then select)\n            year_dropdown_id = 'tbBuscador\\:idFormBuscarProceso\\:anioConvocatoria'\n\n            # Verificar que el dropdown exista (sin validar visibilidad estricta)\n            # Los dos puntos en IDs JSF deben escaparse en querySelector\n            year_dropdown_id_escaped = 'tbBuscador\\\\:idFormBuscarProceso\\\\:anioConvocatoria'\n            await page.wait_for_function(\n                f'document.querySelector("#{year_dropdown_id_escaped}") !== null',\n                timeout=30000\n            )\n            logger.info("Dropdown de año encontrado")\n\n            # Hacer clic en el dropdown usando JavaScript (bypass Playwright visibility check)\n            await page.evaluate(f'''\n                document.querySelector("#{year_dropdown_id_escaped}").click();\n            ''')\n            logger.info("Dropdown de año abierto (JavaScript click)")\n\n            # Esperar a que aparezca el panel del dropdown y hacer clic en la opción usando JavaScript\n            await page.wait_for_timeout(500)  # Esperar animación\n            await page.evaluate(f'''\n                const panel = document.querySelector("#{year_dropdown_id_escaped}_panel");\n                if (panel) {{\n                    const option = Array.from(panel.querySelectorAll(\"li\")).find(li => li.textContent.trim() === \"{anio}\");\n                    if (option) {{\n                        option.click();\n                    }}\n                }}\n            ''')\n            logger.info(f"Año seleccionado: {anio} (JavaScript click)")\n\n            # NO ingresar el CUI - buscar solo por año\n            # El campo CUI en SEACE no funciona correctamente para búsquedas\n            logger.info("Búsqueda solo por año (sin CUI)")\n\n            # Hacer clic en el botón \"Buscar\" usando JavaScript (bypass visibility check)\n            await page.wait_for_timeout(2000)  # Esperar estabilización del formulario\n            button_clicked = await page.evaluate('''\n                (() => {\n                    const buscarButton = Array.from(document.querySelectorAll('button')).find(btn => btn.textContent.includes('Buscar'));\n                    if (buscarButton) {\n                        buscarButton.click();\n                        return true;\n                    }\n                    return false;\n                })()\n            ''')\n            if button_clicked:\n                logger.info("Clic en botón Buscar exitoso (JavaScript)")\n                await page.wait_for_timeout(3000)  # Esperar procesamiento inicial de SEACE\n            else:\n                raise ExtractionException("No se pudo hacer clic en el botón Buscar")\n\n            # Esperar a que aparezca el paginador y que muestre resultados (no \"0 a 0\")\n            logger.info("Esperando que aparezca el paginador de resultados con datos")\n            try:\n                await page.wait_for_function(\n                    '''\n                    (() => {\n                        const paginator = document.querySelector(\"#tbBuscador\\\\:idFormBuscarProceso\\\\:pnlGrdResultadosProcesos .ui-paginator-current\");\n                        if (!paginator) return false;\n                        const text = paginator.textContent.toLowerCase();\n                        return !text.includes('total 0') && !text.includes('0 a 0');\n                    })()\n                    ''',\n                    timeout=30000\n                )\n                logger.info("Paginador con resultados encontrado")\n            except PlaywrightTimeoutError:\n                # Si timeout, verificar el texto del paginador para dar mensaje específico\n                paginator_selector_css = '#tbBuscador\\:idFormBuscarProceso\\:pnlGrdResultadosProcesos .ui-paginator-current'\n                paginator = await page.query_selector(paginator_selector_css)\n                if paginator:\n                    paginator_text = await paginator.inner_text()\n                    logger.error(f"Timeout esperando resultados. Paginador: {paginator_text}")\n                    raise ExtractionException(f"No se encontraron resultados en SEACE para el año {anio}.")\n                else:\n                    logger.error("Timeout: paginador no encontrado")\n                    raise ExtractionException("Timeout esperando paginador de resultados")\n\n            # Confirmar que la columna \"Acciones\" existe (sin validar visibilidad)\n            await page.wait_for_function(\n                'document.evaluate(\"//text()[contains(., \\'Acciones\\')]\", document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue !== null',\n                timeout=10000\n            )\n            logger.info("Resultados de búsqueda cargados completamente")\n\n            # Buscar la fila que contenga el CUI en la descripción\n            logger.info(f"Buscando fila con CUI {cui} en los resultados")\n            fila_encontrada = await page.evaluate(f'''\n                (() => {{\n                    const rows = document.querySelectorAll('#tbBuscador\\\\:idFormBuscarProceso\\\\:pnlGrdResultadosProcesos table tbody tr');\n                    for (let row of rows) {{\n                        const descripcionCell = row.querySelector('td:nth-child(8)'); // Columna \"Descripción de Objeto\"\n                        if (descripcionCell && descripcionCell.textContent.includes('CUI {cui}')) {{\n                            return true;\n                        }}\n                    }}\n                    return false;\n                }})()\n            ''')\n\n            if not fila_encontrada:\n                raise ExtractionException(f"No se encontró ninguna obra con CUI {cui} en los resultados del año {anio}")\n\n        except Exception as e:\n            logger.error(f"Error ejecutando búsqueda: {str(e)}")\n            raise ExtractionException(f"Error ejecutando búsqueda: {str(e)}")\n    \n    async def _navegar_a_historial(self, page: Page, cui: str):\n        """Navega al historial de contratación de la obra con el CUI especificado"""\n        logger.info(f"Navegando a historial de contratación para CUI {cui}")\n\n        try:\n            # Buscar la fila que contenga el CUI y hacer clic en su ícono de historial\n            historial_clicked = await page.evaluate(f'''\n                (() => {{\n                    const rows = document.querySelectorAll('#tbBuscador\\\\:idFormBuscarProceso\\\\:pnlGrdResultadosProcesos table tbody tr');\n                    for (let row of rows) {{\n                        const descripcionCell = row.querySelector('td:nth-child(8)'); // Columna \"Descripción de Objeto\"\n                        if (descripcionCell && descripcionCell.textContent.includes('CUI {cui}')) {{\n                            // Encontrar el primer ícono (historial) en la columna de Acciones (última columna)\n                            const historialIcon = row.querySelector('td:last-child a.ui-commandlink:first-child');\n                            if (historialIcon) {{\n                                historialIcon.click();\n                                return true;\n                            }}\n                        }}\n                    }}\n                    return false;\n                }})()\n            ''')\n\n            if not historial_clicked:\n                raise ExtractionException(f"No se pudo hacer clic en el ícono de historial para CUI {cui}")\n\n            logger.info(f"Clic en ícono de historial para CUI {cui}")\n\n            # Esperar a que cargue el historial - buscar por texto \"Visualizar historial\"\n            await page.wait_for_selector('text=Visualizar historial de contratación', timeout=30000, state='visible')\n            logger.info("Historial cargado")\n\n        except Exception as e:\n            logger.error(f"Error navegando a historial: {str(e)}")\n            raise ExtractionException(f"Error navegando a historial: {str(e)}")\n    \n    async def _navegar_a_ficha_seleccion(self, page: Page):\n        """Navega a la ficha de selección (segundo ícono en la tabla de historial)"""\n        logger.info("Navegando a ficha de selección")\n\n        try:\n            # Esperar a que se cargue la tabla de historial\n            await page.wait_for_selector('table tbody tr', timeout=30000, state='visible')\n\n            # Buscar todos los enlaces en la columna de Acciones (última celda)\n            # El segundo enlace (índice 1) es el ícono de ficha\n            ficha_icons = await page.query_selector_all('table tbody tr td:last-child a.ui-commandlink')\n\n            if len(ficha_icons) < 2:\n                raise ExtractionException(\"No se encontró el ícono de ficha en el historial\")\n\n            # El segundo ícono (índice 1) es la ficha de selección\n            await ficha_icons[1].click()\n            logger.info(\"Clic en ícono de ficha\")\n\n            # Esperar a que cargue la ficha - buscar el tab \"Ficha de Seleccion\"\n            await page.wait_for_selector('text=Ficha de Seleccion', timeout=30000, state='visible')\n            logger.info(\"Ficha cargada\")\n            \n        except Exception as e:\n            logger.error(f\"Error navegando a ficha: {str(e)}\")\n            raise ExtractionException(f\"Error navegando a ficha: {str(e)}\")\n    \n    async def _extraer_informacion_ficha(self, page: Page, cui: str, anio: int) -> ObraSEACE:\n        \"\"\"Extrae toda la información de la ficha de selección\"\"\"\n        logger.info(\"Extrayendo información de la ficha\")\n        \n        try:\n            # Esperar a que la página cargue completamente\n            await page.wait_for_timeout(2000)\n            \n            # Esperar a que aparezca un elemento clave de la ficha\n            await page.wait_for_selector('text=Tipo de documento', timeout=30000, state='visible')\n            logger.info(\"Ficha de documentos cargada\")\n            \n            # Extraer información usando el método de búsqueda por label\n            nomenclatura = await self._extraer_texto_por_label(page, \"Nomenclatura\")\n            normativa_aplicable = await self._extraer_texto_por_label(page, \"Normativa Aplicable\")\n            objeto_contratacion = await self._extraer_texto_por_label(page, \"Objeto de Contratación\")\n            descripcion = await self._extraer_texto_por_label(page, \"Descripción del Objeto\")\n            entidad_convocante = await self._extraer_texto_por_label(page, \"Entidad Convocante\")\n            fecha_publicacion = await self._extraer_texto_por_label(page, \"Fecha y Hora Publicación\")\n            tipo_compra = await self._extraer_texto_por_label(page, \"Tipo Compra o Selección\")\n            numero_convocatoria = await self._extraer_texto_por_label(page, \"N° Convocatoria\")\n            \n            # Extraer monto contractual (formato especial)\n            monto_text = await self._extraer_texto_por_label(page, \"VR / VE / Cuantía de la contratación\")\n            monto_contractual = None\n            if monto_text:\n                # Limpiar el texto y convertir a float\n                monto_limpio = monto_text.replace(',', '').replace(' ', '').strip()\n                try:\n                    monto_contractual = float(monto_limpio)\n                except ValueError:\n                    logger.warning(f\"No se pudo convertir el monto: {monto_text}\")\n            \n            # Validar que se hayan extraído datos mínimos\n            if not nomenclatura:\n                raise ExtractionException(\"No se pudo extraer la nomenclatura de la obra\")\n            \n            # Crear objeto ObraSEACE\n            obra = ObraSEACE(\n                nomenclatura=nomenclatura or \"\",\n                normativa_aplicable=normativa_aplicable or \"\",\n                objeto_contratacion=objeto_contratacion or \"\",\n                descripcion=descripcion or \"\",\n                monto_contractual=monto_contractual,\n                cui=cui,\n                anio=anio,\n                numero_convocatoria=numero_convocatoria,\n                entidad_convocante=entidad_convocante,\n                fecha_publicacion=fecha_publicacion,\n                tipo_compra=tipo_compra,\n                fuente=\"SEACE\"\n            )\n            \n            logger.info(f\"Información extraída exitosamente: {nomenclatura}\")\n            return obra\n            \n        except Exception as e:\n            logger.error(f\"Error extrayendo información de la ficha: {str(e)}\")\n            raise ExtractionException(f\"Error extrayendo información: {str(e)}\")\n    \n    async def _extraer_texto_por_label(self, page: Page, label: str) -> Optional[str]:\n        \"\"\"Extrae el texto asociado a un label específico usando estructura de tabla\"\"\"\n        try:\n            # Buscar todas las filas de tabla\n            rows = await page.query_selector_all('tr')\n            \n            for row in rows:\n                # Buscar las celdas de la fila\n                cells = await row.query_selector_all('td')\n                if len(cells) >= 2:\n                    # Primera celda contiene el label\n                    label_text = await cells[0].inner_text()\n                    label_text = label_text.strip()\n                    \n                    # Comparar con el label buscado (con o sin \":\")\n                    if label_text == label or label_text == f\"{label}:\":\n                        # Segunda celda contiene el valor\n                        value_text = await cells[1].inner_text()\n                        value_text = value_text.strip()\n                        logger.info(f\"Extraído {label}: {value_text}\")\n                        return value_text\n            \n            logger.warning(f\"No se encontró el elemento para {label}\")\n            return None\n        \n        except Exception as e:\n            logger.warning(f\"Error extrayendo {label}: {str(e)}\")\n            return None\n\n\n# Singleton instance\nseace_service = SEACEService()\n